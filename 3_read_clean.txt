def get_sub_df(input_directory):
    """
    Create a DataFrame of armies, extracting relevant columns and
    converting cost/upkeep dictionaries into numeric columns.
    """
    army_data, level_1_attributes, level_2_attributes = parse_army_files(input_directory)
    if not army_data:
        raise ValueError("No data was parsed. Check the Stellaris configuration files.")

    all_columns = ["name"] + sorted(list(level_1_attributes)) + sorted(list(level_2_attributes))
    rows = []
    for army in army_data:
        row = {"name": army.get("name", "")}
        for col in level_1_attributes:
            row[col] = army.get(col, "")
        resources = army.get("resources", {})
        for col in level_2_attributes:
            row[col] = resources.get(col, "")
        rows.append(row)

    df = pd.DataFrame(rows, columns=all_columns)

    # Drop extraneous columns
    cols_to_remove = ['resources', 'icon_frame', 'icon', 'occupation', 'use_armynames_from']
    df.drop(columns=[c for c in cols_to_remove if c in df.columns], inplace=True)

    # Keep only essential attributes
    keep = ['name', 'time', 'damage', 'health', 'morale_damage', 'morale', 'collateral_damage', 'cost', 'upkeep', 'defensive', 
        'war_exhaustion']
    
    df = df[keep].copy()

    # Convert the 'cost' and 'upkeep' columns from strings to dicts
    def convert_to_dict(entry):
        if isinstance(entry, str):
            try:
                return ast.literal_eval(entry)
            except (ValueError, SyntaxError):
                return {}
        elif isinstance(entry, float) or entry is None:
            return {}
        return entry

    df['cost'] = df['cost'].apply(convert_to_dict)
    df['upkeep'] = df['upkeep'].apply(convert_to_dict)

    
    # Expand cost & upkeep dicts into numeric columns
    def parse_resources_column(df_local, column):
        resource_keys = set()
        for entry in df_local[column].dropna():
            if isinstance(entry, dict):
                resource_keys.update(entry.keys())
        for key in resource_keys:
            df_local[f"{column}_{key}"] = df_local[column].apply(
                lambda x: float(x[key]) if isinstance(x, dict) and key in x else 0.0
            )
        return df_local

    df = parse_resources_column(df, 'cost')
    df = parse_resources_column(df, 'upkeep')
    df.drop(columns=['cost', 'upkeep'], inplace=True)

    # Identify relevant numeric columns dynamically
    numeric_cols = ['time', 'morale', 'damage', 'health', 'morale_damage', 
                    'collateral_damage', 'war_exhaustion']
    
    # Dynamically include all cost_* and upkeep_* columns
    cost_cols = [col for col in df.columns if col.startswith('cost_')]
    upkeep_cols = [col for col in df.columns if col.startswith('upkeep_')]
    
    # Combine all numeric columns
    all_numeric_cols = numeric_cols + cost_cols + upkeep_cols
    
    # Convert to numeric and handle 'time' as integer
    df[all_numeric_cols] = df[all_numeric_cols].apply(pd.to_numeric, errors='coerce').fillna(0)
    
    # Ensure cost_* columns and 'time' are integers
    df[cost_cols + ['time']] = df[cost_cols + ['time']].astype(int)

    return df